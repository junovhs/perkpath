<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Itinerary Map Generator</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
            rel="stylesheet"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            :root {
                --bg-dark: #1a1d23;
                --bg-panel: #22262e;
                --bg-input: #2a2f38;
                --border: #363c47;
                --text-primary: #f0f2f5;
                --text-secondary: #8b919a;
                --accent: #00b4d8;
                --accent-hover: #0096c7;
                --success: #4ade80;
                --warning: #fbbf24;
                --error: #f87171;

                --font-sans:
                    "DM Sans", -apple-system, BlinkMacSystemFont, sans-serif;
                --font-mono: "JetBrains Mono", monospace;

                --radius: 8px;
                --radius-lg: 12px;
            }

            html,
            body {
                height: 100%;
                font-family: var(--font-sans);
                background: var(--bg-dark);
                color: var(--text-primary);
                overflow: hidden;
            }

            .app {
                display: flex;
                height: 100vh;
                width: 100vw;
            }

            .sidebar {
                width: 400px;
                min-width: 400px;
                background: var(--bg-panel);
                border-right: 1px solid var(--border);
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .sidebar-header {
                padding: 20px 24px;
                border-bottom: 1px solid var(--border);
                background: linear-gradient(
                    135deg,
                    var(--bg-panel) 0%,
                    #282d36 100%
                );
                flex-shrink: 0;
            }

            .sidebar-header h1 {
                font-size: 1.5rem;
                font-weight: 700;
                letter-spacing: -0.5px;
            }

            .sidebar-header .accent {
                color: var(--accent);
            }

            .tagline {
                font-size: 0.75rem;
                color: var(--text-secondary);
                margin-top: 4px;
                font-family: var(--font-mono);
            }

            .tabs {
                display: flex;
                border-bottom: 1px solid var(--border);
                flex-shrink: 0;
            }

            .tab {
                flex: 1;
                padding: 12px 8px;
                background: transparent;
                border: none;
                color: var(--text-secondary);
                font-family: var(--font-sans);
                font-size: 0.8rem;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s;
                border-bottom: 2px solid transparent;
            }

            .tab:hover {
                color: var(--text-primary);
                background: rgba(255, 255, 255, 0.03);
            }

            .tab.active {
                color: var(--accent);
                border-bottom-color: var(--accent);
            }

            .tab-content {
                display: none;
                flex-direction: column;
                overflow-y: auto;
                flex: 1;
            }

            .tab-content.active {
                display: flex;
            }

            .tab-content::-webkit-scrollbar {
                width: 6px;
            }
            .tab-content::-webkit-scrollbar-track {
                background: transparent;
            }
            .tab-content::-webkit-scrollbar-thumb {
                background: var(--border);
                border-radius: 3px;
            }

            .panel {
                padding: 20px 24px;
                border-bottom: 1px solid var(--border);
            }

            .panel h2 {
                font-size: 0.7rem;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-secondary);
                margin-bottom: 12px;
            }

            input,
            textarea {
                width: 100%;
                background: var(--bg-input);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 10px 14px;
                font-family: var(--font-sans);
                font-size: 0.9rem;
                color: var(--text-primary);
                transition:
                    border-color 0.2s,
                    box-shadow 0.2s;
                resize: vertical;
            }

            input:focus,
            textarea:focus {
                outline: none;
                border-color: var(--accent);
                box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.15);
            }

            textarea {
                min-height: 200px;
                font-family: var(--font-mono);
                font-size: 0.8rem;
                line-height: 1.5;
            }

            input[type="color"] {
                padding: 4px;
                height: 36px;
                cursor: pointer;
            }

            input[type="number"] {
                width: 80px;
            }

            .primary-btn {
                width: 100%;
                padding: 12px 20px;
                margin-top: 12px;
                background: var(--accent);
                color: white;
                border: none;
                border-radius: var(--radius);
                font-family: var(--font-sans);
                font-size: 0.9rem;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .primary-btn:hover:not(:disabled) {
                background: var(--accent-hover);
                transform: translateY(-1px);
            }

            .primary-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .secondary-btn {
                width: 100%;
                padding: 10px 16px;
                margin-top: 8px;
                background: transparent;
                color: var(--text-secondary);
                border: 1px dashed var(--border);
                border-radius: var(--radius);
                font-family: var(--font-sans);
                font-size: 0.85rem;
                cursor: pointer;
                transition: all 0.2s;
            }

            .secondary-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

            .prompt-output {
                background: var(--bg-input);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 14px;
                font-family: var(--font-mono);
                font-size: 0.75rem;
                line-height: 1.6;
                max-height: 400px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-break: break-word;
            }

            .prompt-output .placeholder {
                color: var(--text-secondary);
                font-style: italic;
            }

            .hint {
                font-size: 0.75rem;
                color: var(--text-secondary);
                margin-top: 12px;
                line-height: 1.4;
            }

            .route-types {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .route-type-item {
                background: var(--bg-input);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 12px;
            }

            .route-type-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 10px;
            }

            .route-type-header input[type="text"] {
                flex: 1;
                font-weight: 600;
            }

            .route-type-remove {
                background: transparent;
                border: none;
                color: var(--error);
                cursor: pointer;
                font-size: 1.1rem;
                padding: 4px;
                opacity: 0.6;
                transition: opacity 0.2s;
            }

            .route-type-remove:hover {
                opacity: 1;
            }

            .route-type-options {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .route-type-options label {
                font-size: 0.7rem;
                color: var(--text-secondary);
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .route-type-options input[type="color"] {
                width: 100%;
            }

            .route-type-options select {
                background: var(--bg-dark);
                border: 1px solid var(--border);
                border-radius: 4px;
                padding: 6px 8px;
                color: var(--text-primary);
                font-size: 0.8rem;
            }

            .config-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 12px;
            }

            .config-row label {
                font-size: 0.85rem;
                color: var(--text-secondary);
            }

            .export-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .export-btn {
                padding: 10px 12px;
                background: var(--bg-input);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                color: var(--text-primary);
                font-family: var(--font-sans);
                font-size: 0.8rem;
                cursor: pointer;
                transition: all 0.2s;
            }

            .export-btn:hover {
                border-color: var(--accent);
                background: rgba(0, 180, 216, 0.1);
            }

            .map-container {
                flex: 1;
                position: relative;
                background: var(--bg-dark);
            }

            #map {
                width: 100%;
                height: 100%;
            }

            .legend {
                position: absolute;
                bottom: 30px;
                left: 30px;
                background: white;
                border-radius: var(--radius-lg);
                padding: 16px 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                min-width: 180px;
            }

            .legend h3 {
                font-size: 0.8rem;
                font-weight: 700;
                color: #1a1d23;
                margin-bottom: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
                font-size: 0.85rem;
                color: #1a1d23;
            }

            .legend-item:last-child {
                margin-bottom: 0;
            }

            .legend-line {
                width: 30px;
                height: 4px;
                border-radius: 2px;
            }

            .legend-line.dashed {
                background: repeating-linear-gradient(
                    90deg,
                    currentColor 0px,
                    currentColor 6px,
                    transparent 6px,
                    transparent 10px
                );
                height: 4px;
            }

            .toast {
                position: absolute;
                bottom: 30px;
                right: 30px;
                background: var(--bg-panel);
                color: var(--text-primary);
                padding: 12px 20px;
                border-radius: var(--radius);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                z-index: 1001;
                transform: translateY(100px);
                opacity: 0;
                transition: all 0.3s ease;
            }

            .toast.show {
                transform: translateY(0);
                opacity: 1;
            }

            .toast.success {
                border-left: 4px solid var(--success);
            }
            .toast.error {
                border-left: 4px solid var(--error);
            }

            .leaflet-container {
                background: #a8d4e6;
                font-family: var(--font-sans);
            }

            .location-label-wrapper {
                background: transparent !important;
                border: none !important;
            }

            .location-label-inner {
                padding: 6px 12px;
                border-radius: 6px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                white-space: nowrap;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                font-family:
                    "DM Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    sans-serif;
                display: inline-block;
            }

            .arrow-icon {
                background: transparent !important;
                border: none !important;
            }

            .leaflet-control-zoom {
                border: none !important;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15) !important;
            }

            .leaflet-control-zoom a {
                background: white !important;
                color: #1a1d23 !important;
                border: none !important;
            }

            .leaflet-control-zoom a:hover {
                background: #f0f2f5 !important;
            }
        </style>
    </head>
    <body>
        <div class="app">
            <aside class="sidebar">
                <header class="sidebar-header">
                    <h1>Route<span class="accent">Map</span></h1>
                    <p class="tagline">Itinerary ‚Üí Prompt ‚Üí JSON ‚Üí Map</p>
                </header>

                <nav class="tabs">
                    <button class="tab active" data-tab="input">
                        1. Input
                    </button>
                    <button class="tab" data-tab="prompt">2. Prompt</button>
                    <button class="tab" data-tab="render">3. Render</button>
                    <button class="tab" data-tab="config">Config</button>
                </nav>

                <section class="tab-content active" data-tab="input">
                    <div class="panel">
                        <h2>Paste Your Itinerary</h2>
                        <textarea
                            id="itineraryInput"
                            placeholder="Part 1: South Africa, Victoria Falls, & Nairobi
Start in Cape Town
Fly to Kruger
Fly to Victoria Falls
Fly to Nairobi

Part 2: Tanzania
Start in Arusha
Drive to Serengeti National Park
Drive to Ngorongoro Crater
Drive back to Arusha"
                        ></textarea>
                        <button id="generatePrompt" class="primary-btn">
                            Generate AI Prompt ‚Üí
                        </button>
                    </div>
                </section>

                <section class="tab-content" data-tab="prompt">
                    <div class="panel">
                        <h2>Copy This Prompt to AI</h2>
                        <div class="prompt-output" id="promptOutput">
                            <span class="placeholder"
                                >Enter itinerary text first...</span
                            >
                        </div>
                        <button id="copyPrompt" class="primary-btn" disabled>
                            üìã Copy to Clipboard
                        </button>
                        <p class="hint">
                            Paste this to Claude, ChatGPT, etc. Then paste the
                            JSON response in the Render tab.
                        </p>
                    </div>
                </section>

                <section class="tab-content" data-tab="render">
                    <div class="panel">
                        <h2>Paste AI Response (JSON)</h2>
                        <textarea
                            id="jsonInput"
                            placeholder='{
  "title": "My Trip",
  "locations": [...],
  "segments": [...]
}'
                        ></textarea>
                        <button id="renderMap" class="primary-btn">
                            üó∫Ô∏è Render Map
                        </button>
                    </div>

                    <div class="panel">
                        <h2>Or Load Example</h2>
                        <button id="loadExample" class="secondary-btn">
                            Load Alaska Example
                        </button>
                    </div>

                    <div class="panel">
                        <h2>Export Layers</h2>
                        <div class="export-buttons">
                            <button class="export-btn" data-export="full">
                                Full Map
                            </button>
                            <button class="export-btn" data-export="base">
                                Base Only
                            </button>
                            <button class="export-btn" data-export="labels">
                                Labels Only
                            </button>
                            <button class="export-btn" data-export="routes">
                                Routes Only
                            </button>
                        </div>
                    </div>
                </section>

                <section class="tab-content" data-tab="config">
                    <div class="panel">
                        <h2>Route Types</h2>
                        <p class="hint">
                            Configure how different transport modes appear on
                            the map.
                        </p>
                        <div id="routeTypes" class="route-types"></div>
                        <button id="addRouteType" class="secondary-btn">
                            + Add Route Type
                        </button>
                    </div>

                    <div class="panel">
                        <h2>Label Style</h2>
                        <div class="config-row">
                            <label>Font Size</label>
                            <input
                                type="number"
                                id="labelFontSize"
                                value="14"
                                min="8"
                                max="24"
                            />
                        </div>
                        <div class="config-row">
                            <label>Background</label>
                            <input
                                type="color"
                                id="labelBgColor"
                                value="#ffffff"
                            />
                        </div>
                        <div class="config-row">
                            <label>Text Color</label>
                            <input
                                type="color"
                                id="labelTextColor"
                                value="#1a1d23"
                            />
                        </div>
                    </div>

                    <div class="panel">
                        <h2>Node Style</h2>
                        <div class="config-row">
                            <label>Size</label>
                            <input
                                type="number"
                                id="nodeSize"
                                value="12"
                                min="6"
                                max="24"
                            />
                        </div>
                        <div class="config-row">
                            <label>Border Width</label>
                            <input
                                type="number"
                                id="nodeBorderWidth"
                                value="3"
                                min="1"
                                max="8"
                            />
                        </div>
                    </div>
                </section>
            </aside>

            <main class="map-container">
                <div id="map"></div>

                <div id="legend" class="legend">
                    <h3>Legend</h3>
                    <div id="legendItems"></div>
                </div>

                <div id="toast" class="toast"></div>
            </main>
        </div>

        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://unpkg.com/@turf/turf@7/turf.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

        <script>
            // Default route types matching user's Alaska map
            const DEFAULT_ROUTE_TYPES = [
                {
                    id: "drive",
                    name: "Motorcoach / Drive",
                    color: "#00b4d8",
                    lineStyle: "solid",
                    lineWidth: 5,
                },
                {
                    id: "rail",
                    name: "Rail",
                    color: "#00b4d8",
                    lineStyle: "dashed",
                    lineWidth: 5,
                },
                {
                    id: "cruise",
                    name: "Cruise / Boat",
                    color: "#f97316",
                    lineStyle: "solid",
                    lineWidth: 5,
                },
                {
                    id: "fly",
                    name: "Flight",
                    color: "#a855f7",
                    lineStyle: "dashed",
                    lineWidth: 4,
                },
            ];

            const DEFAULT_CONFIG = {
                routeTypes: DEFAULT_ROUTE_TYPES,
                labelStyle: {
                    fontSize: 14,
                    bgColor: "#ffffff",
                    textColor: "#1a1d23",
                },
                nodeStyle: { size: 12, borderWidth: 3 },
            };

            // Alaska example data
            const ALASKA_EXAMPLE = {
                title: "Alaska Cruise & Land Tour",
                locations: [
                    {
                        name: "Denali Ntl Park",
                        lat: 63.1148,
                        lng: -151.1926,
                        isStart: true,
                        labelPosition: "left",
                    },
                    {
                        name: "Talkeetna",
                        lat: 62.3209,
                        lng: -150.1066,
                        labelPosition: "top",
                    },
                    {
                        name: "Anchorage",
                        lat: 61.2181,
                        lng: -149.9003,
                        labelPosition: "left",
                    },
                    {
                        name: "Girdwood",
                        lat: 60.9426,
                        lng: -149.1663,
                        labelPosition: "top-right",
                    },
                    {
                        name: "Seward",
                        lat: 60.1042,
                        lng: -149.4422,
                        labelPosition: "left",
                    },
                    {
                        name: "Hubbard Glacier",
                        lat: 60.0192,
                        lng: -139.4716,
                        labelPosition: "top-right",
                    },
                    {
                        name: "Skagway",
                        lat: 59.4583,
                        lng: -135.3139,
                        labelPosition: "right",
                    },
                    {
                        name: "Sitka",
                        lat: 57.0531,
                        lng: -135.33,
                        labelPosition: "right",
                    },
                    {
                        name: "Ketchikan",
                        lat: 55.3422,
                        lng: -131.6461,
                        labelPosition: "right",
                    },
                    {
                        name: "Vancouver",
                        lat: 49.2827,
                        lng: -123.1207,
                        isEnd: true,
                        labelPosition: "bottom",
                    },
                ],
                segments: [
                    {
                        from: "Denali Ntl Park",
                        to: "Talkeetna",
                        transport: "rail",
                    },
                    { from: "Talkeetna", to: "Anchorage", transport: "rail" },
                    { from: "Anchorage", to: "Girdwood", transport: "drive" },
                    { from: "Girdwood", to: "Seward", transport: "drive" },
                    {
                        from: "Seward",
                        to: "Hubbard Glacier",
                        transport: "cruise",
                    },
                    {
                        from: "Hubbard Glacier",
                        to: "Skagway",
                        transport: "cruise",
                    },
                    { from: "Skagway", to: "Sitka", transport: "cruise" },
                    { from: "Sitka", to: "Ketchikan", transport: "cruise" },
                    { from: "Ketchikan", to: "Vancouver", transport: "cruise" },
                ],
            };

            // Prompt generator
            function generatePrompt(itineraryText, routeTypes) {
                const transportTypes = routeTypes
                    .map((rt) => `"${rt.id}"`)
                    .join(" | ");

                return `You are a travel itinerary parser. Parse the itinerary and return ONLY valid JSON.

TRANSPORT TYPES: ${transportTypes}

PARSING RULES:
‚Ä¢ Extract all locations (cities, parks, airports, landmarks)
‚Ä¢ Get accurate lat/lng coordinates for each
‚Ä¢ Determine transport mode from context:
  - "fly/flight" ‚Üí fly
  - "drive/motor/bus/coach" ‚Üí drive
  - "rail/train" ‚Üí rail
  - "cruise/sail/boat/ferry" ‚Üí cruise
  - Default to "drive" if unclear
‚Ä¢ First location: isStart: true
‚Ä¢ Last location: isEnd: true
‚Ä¢ OPTIONAL: If locations are geographically close together, add "labelPosition" to help avoid overlaps. Options: "right", "left", "top", "bottom", "top-right", "top-left", "bottom-right", "bottom-left"

EXAMPLE INPUT:
Part 1: Alaska
Start in Anchorage
Take rail to Denali
Drive to Fairbanks

EXAMPLE OUTPUT:
{
  "title": "Alaska Adventure",
  "locations": [
    { "name": "Anchorage", "lat": 61.2181, "lng": -149.9003, "isStart": true },
    { "name": "Denali National Park", "lat": 63.1148, "lng": -151.1926, "labelPosition": "left" },
    { "name": "Fairbanks", "lat": 64.8378, "lng": -147.7164, "isEnd": true }
  ],
  "segments": [
    { "from": "Anchorage", "to": "Denali National Park", "transport": "rail" },
    { "from": "Denali National Park", "to": "Fairbanks", "transport": "drive" }
  ]
}

NOW PARSE THIS ITINERARY (return ONLY JSON, no markdown code blocks):

${itineraryText}`;
            }

            // Map Renderer Class
            class MapRenderer {
                constructor(containerId, config) {
                    this.config = config;
                    this.currentData = null;
                    this.placedLabels = []; // Track placed label positions for collision detection

                    this.map = L.map(containerId, {
                        zoomControl: true,
                        attributionControl: true,
                    }).setView([40, -95], 4);

                    L.tileLayer(
                        "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",
                        {
                            attribution: "&copy; OpenStreetMap &copy; CARTO",
                            subdomains: "abcd",
                            maxZoom: 19,
                        },
                    ).addTo(this.map);

                    this.routesLayer = L.layerGroup().addTo(this.map);
                    this.arrowsLayer = L.layerGroup().addTo(this.map);
                    this.nodesLayer = L.layerGroup().addTo(this.map);
                    this.labelsLayer = L.layerGroup().addTo(this.map);

                    // Re-render labels on zoom change for better placement
                    this.map.on("zoomend", () => {
                        if (this.currentData) {
                            this.redrawLabels();
                        }
                    });
                }

                redrawLabels() {
                    this.labelsLayer.clearLayers();
                    this.placedLabels = [];

                    const sortedLocations = [
                        ...this.currentData.locations,
                    ].sort((a, b) => {
                        if (a.isStart) return -1;
                        if (b.isStart) return 1;
                        if (a.isEnd) return -1;
                        if (b.isEnd) return 1;
                        return 0;
                    });

                    sortedLocations.forEach((loc) =>
                        this.drawLabelSmart(loc, this.currentData.locations),
                    );
                }

                updateConfig(config) {
                    this.config = config;
                    if (this.currentData) this.render(this.currentData);
                }

                clear() {
                    this.routesLayer.clearLayers();
                    this.nodesLayer.clearLayers();
                    this.labelsLayer.clearLayers();
                    this.arrowsLayer.clearLayers();
                    this.placedLabels = [];
                    this.currentData = null;
                }

                render(data) {
                    this.clear();
                    this.currentData = data;

                    const locationMap = {};
                    data.locations.forEach(
                        (loc) => (locationMap[loc.name] = loc),
                    );

                    // Store all curve points for arrow sizing
                    this.allCurves = [];
                    data.segments.forEach((segment) =>
                        this.drawSegment(segment, locationMap),
                    );

                    // Draw nodes
                    data.locations.forEach((loc) => this.drawNode(loc));

                    // Draw labels with smart placement - prioritize start/end
                    const sortedLocations = [...data.locations].sort((a, b) => {
                        if (a.isStart) return -1;
                        if (b.isStart) return 1;
                        if (a.isEnd) return -1;
                        if (b.isEnd) return 1;
                        return 0;
                    });

                    this.placedLabels = [];
                    sortedLocations.forEach((loc) =>
                        this.drawLabelSmart(loc, data.locations),
                    );

                    this.fitBounds(data.locations);
                    this.updateLegend(data.segments);
                }

                getRouteConfig(transport) {
                    return this.config.routeTypes.find(
                        (rt) =>
                            rt.id.toLowerCase() === transport.toLowerCase() ||
                            rt.name
                                .toLowerCase()
                                .includes(transport.toLowerCase()),
                    );
                }

                drawSegment(segment, locationMap) {
                    const from = locationMap[segment.from];
                    const to = locationMap[segment.to];

                    if (!from || !to) {
                        console.warn(
                            `Could not find locations for segment: ${segment.from} -> ${segment.to}`,
                        );
                        return;
                    }

                    const routeConfig = this.getRouteConfig(segment.transport);
                    const color = routeConfig?.color || "#888888";
                    const isDashed = routeConfig?.lineStyle === "dashed";
                    const weight = routeConfig?.lineWidth || 4;

                    const curvePoints = this.generateBezierCurve(from, to);
                    this.allCurves.push({ points: curvePoints, color, weight });

                    const polyline = L.polyline(curvePoints, {
                        color: color,
                        weight: weight,
                        opacity: 1,
                        lineCap: "round",
                        lineJoin: "round",
                        dashArray: isDashed ? "12, 8" : undefined,
                    });

                    polyline.addTo(this.routesLayer);
                    this.addDirectionArrows(curvePoints, color, weight);
                }

                generateBezierCurve(from, to) {
                    const start = turf.point([from.lng, from.lat]);
                    const end = turf.point([to.lng, to.lat]);

                    const distance = turf.distance(start, end, {
                        units: "kilometers",
                    });
                    const bearing = turf.bearing(start, end);
                    const midPoint = turf.midpoint(start, end);

                    const offsetDistance = distance * 0.15;
                    const controlPoint = turf.destination(
                        midPoint,
                        offsetDistance,
                        bearing + 90,
                        { units: "kilometers" },
                    );

                    const line = turf.lineString([
                        [from.lng, from.lat],
                        controlPoint.geometry.coordinates,
                        [to.lng, to.lat],
                    ]);

                    const curved = turf.bezierSpline(line, {
                        resolution: 10000,
                        sharpness: 0.85,
                    });
                    return curved.geometry.coordinates.map((coord) => [
                        coord[1],
                        coord[0],
                    ]);
                }

                addDirectionArrows(points, color, weight) {
                    if (points.length < 2) return;

                    const totalPoints = points.length;

                    // Calculate path length to determine arrow size and count
                    let pathLength = 0;
                    for (let i = 1; i < points.length; i++) {
                        const dx = points[i][0] - points[i - 1][0];
                        const dy = points[i][1] - points[i - 1][1];
                        pathLength += Math.sqrt(dx * dx + dy * dy);
                    }

                    // Arrow size scales with line weight but has a minimum
                    const arrowSize = Math.max(12, weight * 2.5);

                    // Add arrow at middle of path
                    const index = Math.floor(totalPoints * 0.5);

                    if (index > 0 && index < totalPoints - 1) {
                        const point = points[index];
                        const prevPoint =
                            points[index - 3] || points[index - 1];
                        const nextPoint =
                            points[index + 3] || points[index + 1];

                        // Calculate angle using points further apart for smoother direction
                        const angle =
                            Math.atan2(
                                nextPoint[0] - prevPoint[0],
                                nextPoint[1] - prevPoint[1],
                            ) *
                            (180 / Math.PI);

                        const arrowIcon = L.divIcon({
                            className: "arrow-icon",
                            html: `<svg width="${arrowSize * 2}" height="${arrowSize * 2}" viewBox="0 0 24 24" style="transform: rotate(${angle}deg); filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));">
          <path d="M12 4 L20 16 L12 13 L4 16 Z" fill="${color}" stroke="white" stroke-width="1.5"/>
        </svg>`,
                            iconSize: [arrowSize * 2, arrowSize * 2],
                            iconAnchor: [arrowSize, arrowSize],
                        });

                        L.marker(point, {
                            icon: arrowIcon,
                            interactive: false,
                        }).addTo(this.arrowsLayer);
                    }
                }

                drawNode(location) {
                    const { size, borderWidth } = this.config.nodeStyle;
                    let nodeColor = "#f97316";

                    if (location.isStart) nodeColor = "#22c55e";

                    const marker = L.circleMarker(
                        [location.lat, location.lng],
                        {
                            radius: size,
                            fillColor: nodeColor,
                            fillOpacity: 1,
                            color: "#ffffff",
                            weight: borderWidth,
                            opacity: 1,
                        },
                    );

                    marker.addTo(this.nodesLayer);
                }

                // Estimate label dimensions based on text
                estimateLabelSize(text, fontSize) {
                    // Rough estimation: each character ~0.6 of font size width
                    const charWidth = fontSize * 0.65;
                    const padding = 24; // 12px on each side
                    const width = text.length * charWidth + padding;
                    const height = fontSize + 12; // 6px padding top/bottom
                    return { width, height };
                }

                // Convert lat/lng to approximate pixel position for collision detection
                latLngToPixel(lat, lng) {
                    const point = this.map.latLngToContainerPoint([lat, lng]);
                    return { x: point.x, y: point.y };
                }

                // Check if two rectangles overlap
                rectsOverlap(r1, r2, padding = 5) {
                    return !(
                        r1.right + padding < r2.left - padding ||
                        r1.left - padding > r2.right + padding ||
                        r1.bottom + padding < r2.top - padding ||
                        r1.top - padding > r2.bottom + padding
                    );
                }

                // Get label rectangle at a given position
                getLabelRect(pixelPos, labelSize, position) {
                    const offsets = {
                        right: { x: 15, y: -labelSize.height / 2 },
                        left: {
                            x: -labelSize.width - 15,
                            y: -labelSize.height / 2,
                        },
                        top: {
                            x: -labelSize.width / 2,
                            y: -labelSize.height - 15,
                        },
                        bottom: { x: -labelSize.width / 2, y: 15 },
                        "top-right": { x: 10, y: -labelSize.height - 10 },
                        "top-left": {
                            x: -labelSize.width - 10,
                            y: -labelSize.height - 10,
                        },
                        "bottom-right": { x: 10, y: 10 },
                        "bottom-left": { x: -labelSize.width - 10, y: 10 },
                    };

                    const offset = offsets[position] || offsets["right"];

                    return {
                        left: pixelPos.x + offset.x,
                        top: pixelPos.y + offset.y,
                        right: pixelPos.x + offset.x + labelSize.width,
                        bottom: pixelPos.y + offset.y + labelSize.height,
                        position: position,
                    };
                }

                // Find best label position to avoid overlaps
                findBestLabelPosition(location, labelSize, allLocations) {
                    const pixelPos = this.latLngToPixel(
                        location.lat,
                        location.lng,
                    );

                    // Positions to try, in order of preference
                    const positions = [
                        "right",
                        "top-right",
                        "bottom-right",
                        "left",
                        "top-left",
                        "bottom-left",
                        "top",
                        "bottom",
                    ];

                    let bestPosition = "right";
                    let bestScore = -Infinity;

                    for (const pos of positions) {
                        const rect = this.getLabelRect(
                            pixelPos,
                            labelSize,
                            pos,
                        );
                        let score = 0;
                        let hasOverlap = false;

                        // Check overlap with already placed labels
                        for (const placed of this.placedLabels) {
                            if (this.rectsOverlap(rect, placed.rect)) {
                                hasOverlap = true;
                                score -= 100;
                            }
                        }

                        // Check overlap with other nodes
                        for (const otherLoc of allLocations) {
                            if (otherLoc.name === location.name) continue;
                            const otherPixel = this.latLngToPixel(
                                otherLoc.lat,
                                otherLoc.lng,
                            );
                            const nodeRadius = this.config.nodeStyle.size + 5;
                            const nodeRect = {
                                left: otherPixel.x - nodeRadius,
                                top: otherPixel.y - nodeRadius,
                                right: otherPixel.x + nodeRadius,
                                bottom: otherPixel.y + nodeRadius,
                            };
                            if (this.rectsOverlap(rect, nodeRect)) {
                                score -= 50;
                            }
                        }

                        // Prefer right-side positions
                        if (pos.includes("right")) score += 10;
                        // Slight preference for top positions
                        if (pos.includes("top")) score += 5;

                        if (score > bestScore) {
                            bestScore = score;
                            bestPosition = pos;
                        }

                        // If we found a non-overlapping position, use it
                        if (!hasOverlap && score >= 0) {
                            bestPosition = pos;
                            break;
                        }
                    }

                    return bestPosition;
                }

                // Get anchor point based on position
                getAnchorForPosition(position, labelSize) {
                    const anchors = {
                        right: [-15, labelSize.height / 2],
                        left: [labelSize.width + 15, labelSize.height / 2],
                        top: [labelSize.width / 2, labelSize.height + 15],
                        bottom: [labelSize.width / 2, -15],
                        "top-right": [-10, labelSize.height + 10],
                        "top-left": [
                            labelSize.width + 10,
                            labelSize.height + 10,
                        ],
                        "bottom-right": [-10, -10],
                        "bottom-left": [labelSize.width + 10, -10],
                    };
                    return anchors[position] || anchors["right"];
                }

                drawLabelSmart(location, allLocations) {
                    const { fontSize, bgColor, textColor } =
                        this.config.labelStyle;
                    const labelSize = this.estimateLabelSize(
                        location.name,
                        fontSize,
                    );

                    // Use manual position if specified, otherwise find best position
                    const position =
                        location.labelPosition ||
                        this.findBestLabelPosition(
                            location,
                            labelSize,
                            allLocations,
                        );
                    const anchor = this.getAnchorForPosition(
                        position,
                        labelSize,
                    );

                    // Store placed label for collision detection
                    const pixelPos = this.latLngToPixel(
                        location.lat,
                        location.lng,
                    );
                    const rect = this.getLabelRect(
                        pixelPos,
                        labelSize,
                        position,
                    );
                    this.placedLabels.push({ location, rect, position });

                    const icon = L.divIcon({
                        className: "location-label-wrapper",
                        html: `<div class="location-label-inner" style="
        background: ${location.isStart ? "#22c55e" : location.isEnd ? "#1a1d23" : bgColor};
        color: ${location.isStart || location.isEnd ? "#ffffff" : textColor};
        font-size: ${fontSize}px;
      ">${location.name}</div>`,
                        iconAnchor: anchor,
                    });

                    L.marker([location.lat, location.lng], {
                        icon,
                        interactive: false,
                    }).addTo(this.labelsLayer);
                }

                fitBounds(locations) {
                    if (locations.length === 0) return;
                    const bounds = L.latLngBounds(
                        locations.map((loc) => [loc.lat, loc.lng]),
                    );
                    this.map.fitBounds(bounds, { padding: [80, 80] });
                }

                updateLegend(segments) {
                    const legendItems = document.getElementById("legendItems");
                    if (!legendItems) return;

                    const usedTransports = new Set(
                        segments.map((s) => s.transport.toLowerCase()),
                    );
                    legendItems.innerHTML = "";

                    this.config.routeTypes
                        .filter((rt) => usedTransports.has(rt.id.toLowerCase()))
                        .forEach((rt) => {
                            const item = document.createElement("div");
                            item.className = "legend-item";

                            const line = document.createElement("div");
                            line.className = `legend-line ${rt.lineStyle === "dashed" ? "dashed" : ""}`;
                            line.style.backgroundColor =
                                rt.lineStyle === "dashed"
                                    ? "transparent"
                                    : rt.color;
                            line.style.color = rt.color;
                            if (rt.lineStyle !== "dashed")
                                line.style.background = rt.color;

                            const label = document.createElement("span");
                            label.textContent = rt.name;

                            item.appendChild(line);
                            item.appendChild(label);
                            legendItems.appendChild(item);
                        });
                }

                setLayerVisibility(layer, visible) {
                    const layerMap = {
                        routes: this.routesLayer,
                        nodes: this.nodesLayer,
                        labels: this.labelsLayer,
                        arrows: this.arrowsLayer,
                    };

                    if (visible) this.map.addLayer(layerMap[layer]);
                    else this.map.removeLayer(layerMap[layer]);
                }

                async exportImage(options) {
                    const {
                        includeBase = true,
                        includeRoutes = true,
                        includeLabels = true,
                    } = options;

                    const routesVisible = this.map.hasLayer(this.routesLayer);
                    const nodesVisible = this.map.hasLayer(this.nodesLayer);
                    const labelsVisible = this.map.hasLayer(this.labelsLayer);
                    const arrowsVisible = this.map.hasLayer(this.arrowsLayer);

                    if (!includeRoutes) {
                        this.map.removeLayer(this.routesLayer);
                        this.map.removeLayer(this.nodesLayer);
                        this.map.removeLayer(this.arrowsLayer);
                    }
                    if (!includeLabels) {
                        this.map.removeLayer(this.labelsLayer);
                    }

                    const mapContainer = document.getElementById("map");
                    const canvas = await html2canvas(mapContainer, {
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: includeBase ? null : "transparent",
                    });

                    if (routesVisible) this.map.addLayer(this.routesLayer);
                    if (nodesVisible) this.map.addLayer(this.nodesLayer);
                    if (labelsVisible) this.map.addLayer(this.labelsLayer);
                    if (arrowsVisible) this.map.addLayer(this.arrowsLayer);

                    return canvas.toDataURL("image/png");
                }
            }

            // Main App
            class App {
                constructor() {
                    this.config = this.loadConfig();
                    this.mapRenderer = new MapRenderer("map", this.config);
                    this.generatedPrompt = "";
                    this.initializeUI();
                    this.renderRouteTypes();
                }

                loadConfig() {
                    const saved = localStorage.getItem("itinerary-map-config");
                    if (saved) {
                        try {
                            return JSON.parse(saved);
                        } catch {
                            return DEFAULT_CONFIG;
                        }
                    }
                    return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                }

                saveConfig() {
                    localStorage.setItem(
                        "itinerary-map-config",
                        JSON.stringify(this.config),
                    );
                }

                initializeUI() {
                    document.querySelectorAll(".tab").forEach((tab) => {
                        tab.addEventListener("click", () =>
                            this.switchTab(tab.getAttribute("data-tab")),
                        );
                    });

                    document
                        .getElementById("generatePrompt")
                        .addEventListener("click", () => this.generatePrompt());
                    document
                        .getElementById("copyPrompt")
                        .addEventListener("click", () => this.copyPrompt());
                    document
                        .getElementById("renderMap")
                        .addEventListener("click", () => this.renderMap());
                    document
                        .getElementById("loadExample")
                        .addEventListener("click", () => this.loadExample());
                    document
                        .getElementById("addRouteType")
                        .addEventListener("click", () => this.addRouteType());

                    document.querySelectorAll(".export-btn").forEach((btn) => {
                        btn.addEventListener("click", () =>
                            this.exportMap(btn.getAttribute("data-export")),
                        );
                    });

                    // Config inputs
                    document
                        .getElementById("labelFontSize")
                        .addEventListener("change", (e) => {
                            this.config.labelStyle.fontSize = parseInt(
                                e.target.value,
                            );
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });

                    document
                        .getElementById("labelBgColor")
                        .addEventListener("change", (e) => {
                            this.config.labelStyle.bgColor = e.target.value;
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });

                    document
                        .getElementById("labelTextColor")
                        .addEventListener("change", (e) => {
                            this.config.labelStyle.textColor = e.target.value;
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });

                    document
                        .getElementById("nodeSize")
                        .addEventListener("change", (e) => {
                            this.config.nodeStyle.size = parseInt(
                                e.target.value,
                            );
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });

                    document
                        .getElementById("nodeBorderWidth")
                        .addEventListener("change", (e) => {
                            this.config.nodeStyle.borderWidth = parseInt(
                                e.target.value,
                            );
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });

                    document.getElementById("labelFontSize").value =
                        this.config.labelStyle.fontSize;
                    document.getElementById("labelBgColor").value =
                        this.config.labelStyle.bgColor;
                    document.getElementById("labelTextColor").value =
                        this.config.labelStyle.textColor;
                    document.getElementById("nodeSize").value =
                        this.config.nodeStyle.size;
                    document.getElementById("nodeBorderWidth").value =
                        this.config.nodeStyle.borderWidth;
                }

                switchTab(tabId) {
                    document
                        .querySelectorAll(".tab")
                        .forEach((t) => t.classList.remove("active"));
                    document
                        .querySelectorAll(".tab-content")
                        .forEach((c) => c.classList.remove("active"));

                    document
                        .querySelector(`.tab[data-tab="${tabId}"]`)
                        .classList.add("active");
                    document
                        .querySelector(`.tab-content[data-tab="${tabId}"]`)
                        .classList.add("active");
                }

                generatePrompt() {
                    const input = document
                        .getElementById("itineraryInput")
                        .value.trim();

                    if (!input) {
                        this.showToast(
                            "Please enter itinerary text first",
                            "error",
                        );
                        return;
                    }

                    this.generatedPrompt = generatePrompt(
                        input,
                        this.config.routeTypes,
                    );

                    document.getElementById("promptOutput").textContent =
                        this.generatedPrompt;
                    document.getElementById("copyPrompt").disabled = false;

                    this.switchTab("prompt");
                    this.showToast(
                        "Prompt generated! Copy and paste to AI.",
                        "success",
                    );
                }

                async copyPrompt() {
                    if (!this.generatedPrompt) return;

                    try {
                        await navigator.clipboard.writeText(
                            this.generatedPrompt,
                        );
                        this.showToast("Copied to clipboard!", "success");
                    } catch (err) {
                        this.showToast("Failed to copy", "error");
                    }
                }

                renderMap() {
                    const jsonInput = document
                        .getElementById("jsonInput")
                        .value.trim();

                    if (!jsonInput) {
                        this.showToast("Please paste JSON data first", "error");
                        return;
                    }

                    try {
                        let cleanJson = jsonInput;
                        if (cleanJson.startsWith("```")) {
                            cleanJson = cleanJson
                                .replace(/```json?\n?/g, "")
                                .replace(/```$/g, "")
                                .trim();
                        }

                        const data = JSON.parse(cleanJson);

                        if (!data.locations || !data.segments) {
                            throw new Error(
                                "Invalid JSON structure: missing locations or segments",
                            );
                        }

                        this.mapRenderer.render(data);
                        this.showToast(
                            `Rendered ${data.locations.length} locations!`,
                            "success",
                        );
                    } catch (err) {
                        console.error("Parse error:", err);
                        this.showToast(
                            `JSON parse error: ${err.message}`,
                            "error",
                        );
                    }
                }

                loadExample() {
                    document.getElementById("jsonInput").value = JSON.stringify(
                        ALASKA_EXAMPLE,
                        null,
                        2,
                    );
                    this.renderMap();
                }

                renderRouteTypes() {
                    const container = document.getElementById("routeTypes");
                    container.innerHTML = "";

                    this.config.routeTypes.forEach((rt, index) => {
                        const item = this.createRouteTypeElement(rt, index);
                        container.appendChild(item);
                    });
                }

                createRouteTypeElement(routeType, index) {
                    const item = document.createElement("div");
                    item.className = "route-type-item";
                    item.innerHTML = `
      <div class="route-type-header">
        <input type="text" value="${routeType.name}" data-field="name" />
        <button class="route-type-remove" title="Remove">√ó</button>
      </div>
      <div class="route-type-options">
        <label>
          ID (for parsing)
          <input type="text" value="${routeType.id}" data-field="id" style="width: 100%;" />
        </label>
        <label>
          Color
          <input type="color" value="${routeType.color}" data-field="color" />
        </label>
        <label>
          Line Style
          <select data-field="lineStyle">
            <option value="solid" ${routeType.lineStyle === "solid" ? "selected" : ""}>Solid</option>
            <option value="dashed" ${routeType.lineStyle === "dashed" ? "selected" : ""}>Dashed</option>
          </select>
        </label>
        <label>
          Line Width
          <input type="number" value="${routeType.lineWidth}" data-field="lineWidth" min="1" max="12" style="width: 100%;" />
        </label>
      </div>
    `;

                    item.querySelectorAll("input, select").forEach((input) => {
                        input.addEventListener("change", () => {
                            const field = input.getAttribute("data-field");
                            let value = input.value;
                            if (field === "lineWidth") value = parseInt(value);

                            this.config.routeTypes[index][field] = value;
                            this.saveConfig();
                            this.mapRenderer.updateConfig(this.config);
                        });
                    });

                    item.querySelector(".route-type-remove").addEventListener(
                        "click",
                        () => {
                            this.config.routeTypes.splice(index, 1);
                            this.saveConfig();
                            this.renderRouteTypes();
                            this.mapRenderer.updateConfig(this.config);
                        },
                    );

                    return item;
                }

                addRouteType() {
                    const newType = {
                        id: `type${this.config.routeTypes.length + 1}`,
                        name: "New Type",
                        color: "#888888",
                        lineStyle: "solid",
                        lineWidth: 4,
                    };

                    this.config.routeTypes.push(newType);
                    this.saveConfig();
                    this.renderRouteTypes();
                }

                async exportMap(type) {
                    this.showToast("Exporting...", "success");

                    try {
                        let dataUrl;

                        switch (type) {
                            case "full":
                                dataUrl = await this.mapRenderer.exportImage({
                                    includeBase: true,
                                    includeRoutes: true,
                                    includeLabels: true,
                                });
                                break;
                            case "base":
                                dataUrl = await this.mapRenderer.exportImage({
                                    includeBase: true,
                                    includeRoutes: false,
                                    includeLabels: false,
                                });
                                break;
                            case "labels":
                                dataUrl = await this.mapRenderer.exportImage({
                                    includeBase: false,
                                    includeRoutes: false,
                                    includeLabels: true,
                                });
                                break;
                            case "routes":
                                dataUrl = await this.mapRenderer.exportImage({
                                    includeBase: false,
                                    includeRoutes: true,
                                    includeLabels: false,
                                });
                                break;
                            default:
                                return;
                        }

                        const link = document.createElement("a");
                        link.download = `map-${type}-${Date.now()}.png`;
                        link.href = dataUrl;
                        link.click();

                        this.showToast("Export complete!", "success");
                    } catch (err) {
                        console.error("Export error:", err);
                        this.showToast("Export failed", "error");
                    }
                }

                showToast(message, type) {
                    const toast = document.getElementById("toast");
                    toast.textContent = message;
                    toast.className = `toast show ${type}`;

                    setTimeout(() => toast.classList.remove("show"), 3000);
                }
            }

            // Initialize
            document.addEventListener("DOMContentLoaded", () => new App());
        </script>
    </body>
</html>
